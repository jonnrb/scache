// Code generated by protoc-gen-go. DO NOT EDIT.
// source: scache/provider.proto

package scache

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type SupportsTypeResponse struct {
}

func (m *SupportsTypeResponse) Reset()                    { *m = SupportsTypeResponse{} }
func (m *SupportsTypeResponse) String() string            { return proto.CompactTextString(m) }
func (*SupportsTypeResponse) ProtoMessage()               {}
func (*SupportsTypeResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type DiscoveryInfo struct {
	// Types that are valid to be assigned to Info:
	//	*DiscoveryInfo_Inflated
	//	*DiscoveryInfo_BlobAdded
	//	*DiscoveryInfo_BlobRemoved
	Info isDiscoveryInfo_Info `protobuf_oneof:"info"`
}

func (m *DiscoveryInfo) Reset()                    { *m = DiscoveryInfo{} }
func (m *DiscoveryInfo) String() string            { return proto.CompactTextString(m) }
func (*DiscoveryInfo) ProtoMessage()               {}
func (*DiscoveryInfo) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

type isDiscoveryInfo_Info interface {
	isDiscoveryInfo_Info()
}

type DiscoveryInfo_Inflated struct {
	Inflated *Source `protobuf:"bytes,1,opt,name=inflated,oneof"`
}
type DiscoveryInfo_BlobAdded struct {
	BlobAdded *Blob `protobuf:"bytes,2,opt,name=blob_added,json=blobAdded,oneof"`
}
type DiscoveryInfo_BlobRemoved struct {
	BlobRemoved *Blob `protobuf:"bytes,3,opt,name=blob_removed,json=blobRemoved,oneof"`
}

func (*DiscoveryInfo_Inflated) isDiscoveryInfo_Info()    {}
func (*DiscoveryInfo_BlobAdded) isDiscoveryInfo_Info()   {}
func (*DiscoveryInfo_BlobRemoved) isDiscoveryInfo_Info() {}

func (m *DiscoveryInfo) GetInfo() isDiscoveryInfo_Info {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *DiscoveryInfo) GetInflated() *Source {
	if x, ok := m.GetInfo().(*DiscoveryInfo_Inflated); ok {
		return x.Inflated
	}
	return nil
}

func (m *DiscoveryInfo) GetBlobAdded() *Blob {
	if x, ok := m.GetInfo().(*DiscoveryInfo_BlobAdded); ok {
		return x.BlobAdded
	}
	return nil
}

func (m *DiscoveryInfo) GetBlobRemoved() *Blob {
	if x, ok := m.GetInfo().(*DiscoveryInfo_BlobRemoved); ok {
		return x.BlobRemoved
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DiscoveryInfo) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DiscoveryInfo_OneofMarshaler, _DiscoveryInfo_OneofUnmarshaler, _DiscoveryInfo_OneofSizer, []interface{}{
		(*DiscoveryInfo_Inflated)(nil),
		(*DiscoveryInfo_BlobAdded)(nil),
		(*DiscoveryInfo_BlobRemoved)(nil),
	}
}

func _DiscoveryInfo_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DiscoveryInfo)
	// info
	switch x := m.Info.(type) {
	case *DiscoveryInfo_Inflated:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Inflated); err != nil {
			return err
		}
	case *DiscoveryInfo_BlobAdded:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BlobAdded); err != nil {
			return err
		}
	case *DiscoveryInfo_BlobRemoved:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.BlobRemoved); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DiscoveryInfo.Info has unexpected type %T", x)
	}
	return nil
}

func _DiscoveryInfo_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DiscoveryInfo)
	switch tag {
	case 1: // info.inflated
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Source)
		err := b.DecodeMessage(msg)
		m.Info = &DiscoveryInfo_Inflated{msg}
		return true, err
	case 2: // info.blob_added
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Blob)
		err := b.DecodeMessage(msg)
		m.Info = &DiscoveryInfo_BlobAdded{msg}
		return true, err
	case 3: // info.blob_removed
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Blob)
		err := b.DecodeMessage(msg)
		m.Info = &DiscoveryInfo_BlobRemoved{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DiscoveryInfo_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DiscoveryInfo)
	// info
	switch x := m.Info.(type) {
	case *DiscoveryInfo_Inflated:
		s := proto.Size(x.Inflated)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DiscoveryInfo_BlobAdded:
		s := proto.Size(x.BlobAdded)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DiscoveryInfo_BlobRemoved:
		s := proto.Size(x.BlobRemoved)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type ChunkRequest struct {
	Blob  *Blob      `protobuf:"bytes,1,opt,name=blob" json:"blob,omitempty"`
	Range *ByteRange `protobuf:"bytes,2,opt,name=range" json:"range,omitempty"`
}

func (m *ChunkRequest) Reset()                    { *m = ChunkRequest{} }
func (m *ChunkRequest) String() string            { return proto.CompactTextString(m) }
func (*ChunkRequest) ProtoMessage()               {}
func (*ChunkRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *ChunkRequest) GetBlob() *Blob {
	if m != nil {
		return m.Blob
	}
	return nil
}

func (m *ChunkRequest) GetRange() *ByteRange {
	if m != nil {
		return m.Range
	}
	return nil
}

type Chunk struct {
	Blob  *Blob      `protobuf:"bytes,1,opt,name=blob" json:"blob,omitempty"`
	Range *ByteRange `protobuf:"bytes,2,opt,name=range" json:"range,omitempty"`
	Data  []byte     `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Chunk) Reset()                    { *m = Chunk{} }
func (m *Chunk) String() string            { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()               {}
func (*Chunk) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *Chunk) GetBlob() *Blob {
	if m != nil {
		return m.Blob
	}
	return nil
}

func (m *Chunk) GetRange() *ByteRange {
	if m != nil {
		return m.Range
	}
	return nil
}

func (m *Chunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterType((*SupportsTypeResponse)(nil), "scache.SupportsTypeResponse")
	proto.RegisterType((*DiscoveryInfo)(nil), "scache.DiscoveryInfo")
	proto.RegisterType((*ChunkRequest)(nil), "scache.ChunkRequest")
	proto.RegisterType((*Chunk)(nil), "scache.Chunk")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Provider service

type ProviderClient interface {
	// An error is returned if the type is not supported.
	SupportsType(ctx context.Context, in *Source, opts ...grpc.CallOption) (*SupportsTypeResponse, error)
	// Creates an ephemeral source on a provider. Until the |Discover| is closed,
	// the provider will act as a |ChunkStore| for this source, relaying all blob
	// changes.
	Discover(ctx context.Context, in *Source, opts ...grpc.CallOption) (Provider_DiscoverClient, error)
}

type providerClient struct {
	cc *grpc.ClientConn
}

func NewProviderClient(cc *grpc.ClientConn) ProviderClient {
	return &providerClient{cc}
}

func (c *providerClient) SupportsType(ctx context.Context, in *Source, opts ...grpc.CallOption) (*SupportsTypeResponse, error) {
	out := new(SupportsTypeResponse)
	err := grpc.Invoke(ctx, "/scache.Provider/SupportsType", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *providerClient) Discover(ctx context.Context, in *Source, opts ...grpc.CallOption) (Provider_DiscoverClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Provider_serviceDesc.Streams[0], c.cc, "/scache.Provider/Discover", opts...)
	if err != nil {
		return nil, err
	}
	x := &providerDiscoverClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Provider_DiscoverClient interface {
	Recv() (*DiscoveryInfo, error)
	grpc.ClientStream
}

type providerDiscoverClient struct {
	grpc.ClientStream
}

func (x *providerDiscoverClient) Recv() (*DiscoveryInfo, error) {
	m := new(DiscoveryInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Provider service

type ProviderServer interface {
	// An error is returned if the type is not supported.
	SupportsType(context.Context, *Source) (*SupportsTypeResponse, error)
	// Creates an ephemeral source on a provider. Until the |Discover| is closed,
	// the provider will act as a |ChunkStore| for this source, relaying all blob
	// changes.
	Discover(*Source, Provider_DiscoverServer) error
}

func RegisterProviderServer(s *grpc.Server, srv ProviderServer) {
	s.RegisterService(&_Provider_serviceDesc, srv)
}

func _Provider_SupportsType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Source)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProviderServer).SupportsType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scache.Provider/SupportsType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProviderServer).SupportsType(ctx, req.(*Source))
	}
	return interceptor(ctx, in, info, handler)
}

func _Provider_Discover_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Source)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ProviderServer).Discover(m, &providerDiscoverServer{stream})
}

type Provider_DiscoverServer interface {
	Send(*DiscoveryInfo) error
	grpc.ServerStream
}

type providerDiscoverServer struct {
	grpc.ServerStream
}

func (x *providerDiscoverServer) Send(m *DiscoveryInfo) error {
	return x.ServerStream.SendMsg(m)
}

var _Provider_serviceDesc = grpc.ServiceDesc{
	ServiceName: "scache.Provider",
	HandlerType: (*ProviderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SupportsType",
			Handler:    _Provider_SupportsType_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Discover",
			Handler:       _Provider_Discover_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "scache/provider.proto",
}

// Client API for ChunkStore service

type ChunkStoreClient interface {
	// If the message is longer than 12288 bytes, the result will be streamed in
	// chunks not exceeding that length. The |blob| and |range| fields are not
	// sent on subsequent messages.
	GetChunk(ctx context.Context, in *ChunkRequest, opts ...grpc.CallOption) (ChunkStore_GetChunkClient, error)
}

type chunkStoreClient struct {
	cc *grpc.ClientConn
}

func NewChunkStoreClient(cc *grpc.ClientConn) ChunkStoreClient {
	return &chunkStoreClient{cc}
}

func (c *chunkStoreClient) GetChunk(ctx context.Context, in *ChunkRequest, opts ...grpc.CallOption) (ChunkStore_GetChunkClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ChunkStore_serviceDesc.Streams[0], c.cc, "/scache.ChunkStore/GetChunk", opts...)
	if err != nil {
		return nil, err
	}
	x := &chunkStoreGetChunkClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ChunkStore_GetChunkClient interface {
	Recv() (*Chunk, error)
	grpc.ClientStream
}

type chunkStoreGetChunkClient struct {
	grpc.ClientStream
}

func (x *chunkStoreGetChunkClient) Recv() (*Chunk, error) {
	m := new(Chunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ChunkStore service

type ChunkStoreServer interface {
	// If the message is longer than 12288 bytes, the result will be streamed in
	// chunks not exceeding that length. The |blob| and |range| fields are not
	// sent on subsequent messages.
	GetChunk(*ChunkRequest, ChunkStore_GetChunkServer) error
}

func RegisterChunkStoreServer(s *grpc.Server, srv ChunkStoreServer) {
	s.RegisterService(&_ChunkStore_serviceDesc, srv)
}

func _ChunkStore_GetChunk_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ChunkRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChunkStoreServer).GetChunk(m, &chunkStoreGetChunkServer{stream})
}

type ChunkStore_GetChunkServer interface {
	Send(*Chunk) error
	grpc.ServerStream
}

type chunkStoreGetChunkServer struct {
	grpc.ServerStream
}

func (x *chunkStoreGetChunkServer) Send(m *Chunk) error {
	return x.ServerStream.SendMsg(m)
}

var _ChunkStore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "scache.ChunkStore",
	HandlerType: (*ChunkStoreServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetChunk",
			Handler:       _ChunkStore_GetChunk_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "scache/provider.proto",
}

func init() { proto.RegisterFile("scache/provider.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 344 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x92, 0xc1, 0x4f, 0xea, 0x40,
	0x10, 0xc6, 0xdb, 0xf7, 0x80, 0xf4, 0x0d, 0xe5, 0x25, 0xae, 0x60, 0x08, 0xf1, 0x40, 0x7a, 0xd1,
	0x83, 0xa2, 0x42, 0xbc, 0x9a, 0x80, 0x26, 0xe2, 0xcd, 0x2c, 0x5e, 0x3c, 0x99, 0xb6, 0x3b, 0x95,
	0x46, 0xd8, 0xa9, 0xdb, 0x2d, 0x09, 0x47, 0xff, 0x1a, 0xff, 0x4d, 0xd3, 0x6d, 0x4b, 0x40, 0x39,
	0x7a, 0xeb, 0xce, 0xf7, 0x9b, 0x2f, 0x33, 0xf3, 0x15, 0x3a, 0x69, 0xe8, 0x87, 0x73, 0xbc, 0x48,
	0x14, 0xad, 0x62, 0x81, 0x6a, 0x90, 0x28, 0xd2, 0xc4, 0x1a, 0x45, 0xb9, 0x77, 0x58, 0xca, 0x21,
	0x2d, 0x97, 0x24, 0x0b, 0xd1, 0x3b, 0x82, 0xf6, 0x2c, 0x4b, 0x12, 0x52, 0x3a, 0x7d, 0x5a, 0x27,
	0xc8, 0x31, 0x4d, 0x48, 0xa6, 0xe8, 0x7d, 0xda, 0xd0, 0xba, 0x8b, 0xd3, 0x90, 0x56, 0xa8, 0xd6,
	0x0f, 0x32, 0x22, 0x76, 0x06, 0x4e, 0x2c, 0xa3, 0x85, 0xaf, 0x51, 0x74, 0xed, 0xbe, 0x7d, 0xda,
	0x1c, 0xfe, 0x1f, 0x14, 0x8e, 0x83, 0x19, 0x65, 0x2a, 0xc4, 0xa9, 0xc5, 0x37, 0x04, 0x3b, 0x07,
	0x08, 0x16, 0x14, 0xbc, 0xf8, 0x42, 0xa0, 0xe8, 0xfe, 0x31, 0xbc, 0x5b, 0xf1, 0x93, 0x05, 0x05,
	0x53, 0x8b, 0xff, 0xcb, 0x89, 0x71, 0x0e, 0xb0, 0x2b, 0x70, 0x0d, 0xae, 0x70, 0x49, 0x2b, 0x14,
	0xdd, 0xbf, 0x7b, 0x1b, 0x9a, 0x39, 0xc3, 0x0b, 0x64, 0xd2, 0x80, 0x5a, 0x2c, 0x23, 0xf2, 0x9e,
	0xc1, 0xbd, 0x9d, 0x67, 0xf2, 0x8d, 0xe3, 0x7b, 0x86, 0xa9, 0x66, 0x7d, 0xa8, 0xe5, 0x58, 0x39,
	0xe3, 0x8e, 0x05, 0x37, 0x0a, 0x3b, 0x81, 0xba, 0xf2, 0xe5, 0x2b, 0x96, 0x63, 0x1d, 0x6c, 0x90,
	0xb5, 0x46, 0x9e, 0x0b, 0xbc, 0xd0, 0xbd, 0x08, 0xea, 0xc6, 0xfa, 0x17, 0x3d, 0x19, 0x83, 0x9a,
	0xf0, 0xb5, 0x6f, 0x36, 0x74, 0xb9, 0xf9, 0x1e, 0x7e, 0xd8, 0xe0, 0x3c, 0x96, 0xa1, 0xb1, 0x1b,
	0x70, 0xb7, 0x13, 0x61, 0xdf, 0xae, 0xdc, 0x3b, 0xde, 0xbc, 0xf7, 0xe5, 0x66, 0xb1, 0x6b, 0x70,
	0xaa, 0xe0, 0x7e, 0xf4, 0x76, 0xaa, 0xf7, 0x4e, 0xb4, 0x9e, 0x75, 0x69, 0x0f, 0xc7, 0x00, 0x66,
	0xd7, 0x99, 0x26, 0x85, 0x6c, 0x04, 0xce, 0x3d, 0xea, 0x62, 0xf9, 0x76, 0xd5, 0xb4, 0x7d, 0xe6,
	0x5e, 0x6b, 0xa7, 0x9a, 0x5b, 0x04, 0x0d, 0xf3, 0x4b, 0x8d, 0xbe, 0x02, 0x00, 0x00, 0xff, 0xff,
	0xb3, 0x74, 0x29, 0x2f, 0x88, 0x02, 0x00, 0x00,
}
